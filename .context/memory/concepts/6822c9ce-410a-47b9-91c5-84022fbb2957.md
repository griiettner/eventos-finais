---
id: "6822c9ce-410a-47b9-91c5-84022fbb2957"
title: "Frontend API Service Integration"
type: "concept"
tags: ["api","frontend","typescript","authentication","error-handling"]
created: "2026-01-06T03:33:22.927Z"
updated: "2026-01-06T03:33:22.927Z"
related: ["frontend-api","admin-service","authentication","error-handling"]
importance: 0.85
---

# Frontend API Service Integration

# Eventos Finais - Frontend API Integration

## API Service Architecture

### AdminService - Backend Communication
```typescript
// src/services/admin-service.ts
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

// Token getter setup
let getAccessToken: (() => Promise<string>) | null = null;

export function setAuthTokenGetter(getter: () => Promise<string>) {
  getAccessToken = getter;
}

// Generic API call with JWT authentication
async function apiCall<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const token = getAccessToken ? await getAccessToken() : null;
  
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    ...(token ? { 'Authorization': `Bearer ${token}` } : {}),
    ...options.headers
  };

  const response = await fetch(`${API_URL}${endpoint}`, {
    ...options,
    headers
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: response.statusText }));
    throw new Error(error.error || `API error: ${response.status}`);
  }

  return response.json();
}
```

### Chapter Management Methods
```typescript
export class AdminService {
  // Get all chapters
  static async getAllChapters(): Promise<Chapter[]> {
    return apiCall<Chapter[]>('/api/chapters');
  }

  // Get single chapter
  static async getChapter(id: string): Promise<Chapter | null> {
    return apiCall<Chapter>(`/api/chapters/${id}`);
  }

  // Create chapter with error handling
  static async createChapter(chapter: Omit<Chapter, 'id' | 'created_at' | 'updated_at'>): Promise<string> {
    console.log('[AdminService] Creating chapter:', chapter);
    try {
      const result = await apiCall<Chapter>('/api/chapters', {
        method: 'POST',
        body: JSON.stringify(chapter)
      });
      console.log('[AdminService] Chapter created:', result);
      if (!result || !result.id) {
        console.error('[AdminService] Invalid response - no ID:', result);
        throw new Error('No chapter ID returned from API');
      }
      return result.id;
    } catch (error) {
      console.error('[AdminService] createChapter failed:', error);
      throw error;
    }
  }

  // Update chapter
  static async updateChapter(id: string, chapter: Partial<Omit<Chapter, 'id' | 'created_at' | 'updated_at'>>): Promise<void> {
    await apiCall(`/api/chapters/${id}`, {
      method: 'PUT',
      body: JSON.stringify(chapter)
    });
  }

  // Delete chapter
  static async deleteChapter(id: string): Promise<void> {
    await apiCall(`/api/chapters/${id}`, { method: 'DELETE' });
  }
}
```

### Chapter Pages with Field Mapping
```typescript
// Get chapter pages with camelCase → snakeCase conversion
static async getChapterPages(chapterId: string): Promise<ChapterPage[]> {
  const pages = await apiCall<any[]>(`/api/chapters/${chapterId}/pages`);
  // Map camelCase from API to snake_case for frontend
  return pages.map(page => ({
    id: page.id,
    chapter_id: page.chapterId,
    subtitle: page.subtitle,
    page_number: page.pageNumber,
    content: page.content,
    order_index: page.orderIndex,
    created_at: page.createdAt,
    updated_at: page.updatedAt
  }));
}

// Create chapter page
static async createChapterPage(page: Omit<ChapterPage, 'id' | 'created_at' | 'updated_at'>): Promise<string> {
  const result = await apiCall<ChapterPage>(`/api/chapters/${page.chapter_id}/pages`, {
    method: 'POST',
    body: JSON.stringify(page)
  });
  return result.id;
}

// Delete chapter page
static async deleteChapterPage(id: string): Promise<void> {
  await apiCall(`/api/pages/${id}`, { method: 'DELETE' });
}
```

## Authentication Integration

### AuthContext Token Management
```typescript
// src/contexts/AuthContext.tsx
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user: kindeUser, isAuthenticated, isLoading, logout: kindeLogout, getToken } = useKindeAuth();
  const [isAdmin, setIsAdmin] = useState(false);

  // Set up token getter for API calls
  useEffect(() => {
    const tokenGetter = async () => {
      const token = await getToken();
      return token || '';
    };
    setAuthTokenGetter(tokenGetter);
    setFirebaseAuthTokenGetter(tokenGetter);
  }, [getToken]);

  // Check admin role from Kinde claims
  useEffect(() => {
    const init = async () => {
      if (isAuthenticated && kindeUser) {
        const rolesClaim = await getClaim('roles');
        const roles = rolesClaim?.value || [];
        const hasAdminRole = roles.some((role: any) => 
          role === 'admin' || role.key === 'admin' || role.name === 'Admin'
        );
        setIsAdmin(hasAdminRole);
      } else {
        setIsAdmin(false);
      }
    };
    init();
  }, [isAuthenticated, kindeUser, getClaim]);
};
```

## Component Integration

### AddEditChapter Component
```typescript
// src/pages/AddEditChapter.tsx
const handleSave = async () => {
  if (!textTitle.trim()) {
    alert('Por favor, preencha o título do capítulo');
    return;
  }

  setIsSaving(true);
  try {
    let chapterId: string;
    
    if (isEditing && id) {
      chapterId = id;
      await AdminService.updateChapter(chapterId, {
        title: textTitle,
        order_index: chapterNumber
      });
    } else {
      chapterId = await AdminService.createChapter({
        title: textTitle,
        summary: '',
        content: '',
        audio_url: '',
        order_index: chapterNumber
      });
      
      if (!chapterId) {
        throw new Error('Falha ao criar capítulo - ID inválido retornado');
      }
    }

    // Delete existing pages and create new ones (only for edits)
    if (isEditing) {
      try {
        const existingPages = await AdminService.getChapterPages(chapterId);
        for (const page of existingPages) {
          await AdminService.deleteChapterPage(page.id);
        }
      } catch (error) {
        console.warn('Failed to delete existing pages:', error);
      }
    }

    // Save all pages
    for (let i = 0; i < editingPages.length; i++) {
      const page = editingPages[i];
      if (page.content && page.content.trim()) {
        await AdminService.createChapterPage({
          chapter_id: chapterId,
          subtitle: page.subtitle || undefined,
          page_number: page.page_number || i + 1,
          content: page.content,
          order_index: i
        });
      }
    }

    navigate('/admin');
  } catch (error) {
    console.error('Failed to save chapter:', error);
    alert(`Erro ao salvar capítulo: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
  } finally {
    setIsSaving(false);
  }
};
```

### Loading Chapters with Error Handling
```typescript
const loadChapter = async () => {
  if (!id) return;
  
  try {
    const chapter = await AdminService.getChapter(id);
    if (chapter) {
      setTextTitle(chapter.title);
      setChapterNumber(chapter.order_index);
      
      try {
        const pages = await AdminService.getChapterPages(id);
        setEditingPages(pages.length > 0 ? pages : [{ subtitle: '', page_number: 1, content: '', order_index: 0 }]);
      } catch (pagesError) {
        console.warn('Failed to load pages (might be missing Firestore index):', pagesError);
        setEditingPages([{ subtitle: '', page_number: 1, content: '', order_index: 0 }]);
      }
    }
  } catch (error) {
    console.error('Failed to load chapter:', error);
    alert('Erro ao carregar capítulo');
  }
};
```

## FirebaseService Integration

### Progress Management via API
```typescript
// src/services/firebase-service.ts
export class FirebaseService {
  static async updateProgress(chapterId: string, userId: string, progress: Partial<Progress>): Promise<void> {
    await apiCall('/api/progress', {
      method: 'POST',
      body: JSON.stringify({
        chapterId,
        completed: progress.is_completed || false,
        currentPage: 0
      })
    });
  }
}
```

## Type Definitions

### Chapter Interface
```typescript
export interface Chapter {
  id: string;
  title: string;
  summary: string;
  content: string;
  audio_url: string;
  order_index: number;
  created_at?: Timestamp;
  updated_at?: Timestamp;
}
```

### ChapterPage Interface
```typescript
export interface ChapterPage {
  id: string;
  chapter_id: string;
  subtitle: string | null;
  page_number: number;
  content: string;
  order_index: number;
  created_at?: Timestamp;
  updated_at?: Timestamp;
}
```

## Error Handling Strategy

### API Error Handling
```typescript
// Consistent error handling across all API calls
if (!response.ok) {
  const error = await response.json().catch(() => ({ error: response.statusText }));
  throw new Error(error.error || `API error: ${response.status}`);
}
```

### Component Error Boundaries
```typescript
// Try-catch blocks with user-friendly messages
try {
  const result = await AdminService.createChapter(data);
  // Handle success
} catch (error) {
  console.error('Operation failed:', error);
  alert(`Erro: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
}
```

## Performance Considerations

### Request Optimization
- JWT token cached in memory
- Minimal payload sizes
- Proper HTTP methods (GET, POST, PUT, DELETE)
- Error responses without stack traces

### User Experience
- Loading states during API calls
- User-friendly error messages
- Graceful degradation for missing data
- Optimistic updates where appropriate